"""lab_2_controller controller."""

# You may need to import some classes of the controller module. Ex:
#  from controller import Robot, Motor, DistanceSensor
from controller import Robot
import math

# create the Robot instance.
robot = Robot()
state = "speed_measurement"

MAX_SPEED = 6.28


# get the time step of the current world.
timestep = int(robot.getBasicTimeStep())
dt = timestep / 1000

# You should insert a getDevice-like function in order to get the
# instance of a device of the robot. Something like:
#  motor = robot.getDevice('motorname')
#  ds = robot.getDevice('dsname')
#  ds.enable(timestep)

left_motor = robot.getDevice('left wheel motor')
right_motor = robot.getDevice('right wheel motor')

left_motor.setPosition(float('inf'))
right_motor.setPosition(float('inf'))

left_motor.setVelocity(0)
right_motor.setVelocity(0)

ground_sensors = [
    robot.getDevice('gs0'), 
    robot.getDevice('gs1'), 
    robot.getDevice('gs2')
]

for gs in ground_sensors:
    gs.enable(timestep)

elapsed_time = 0
wheel_radius = 0.0205 # values from webots website
axle_length = 0.0520
EPUCK_MAX_WHEEL_SPEED = 0.129 #(20.5 *  MAX_SPEED)/1000 = 0.129

x = 0
y = 0
theta = 0

left_w = 0
right_w = 0

start_line_time = 0
on_start_line = False

# Main loop:
# - perform simulation steps until Webots is stopping the controller
while robot.step(timestep) != -1:
    # Read the sensors:
    gs_values = [gs.getValue() for gs in ground_sensors] 
    
    start_line = (gs_values[0] < 700 and gs_values[1] < 700 and gs_values[2] < 700)
    
    if start_line:
        start_line_time += dt
    else:
        start_line_time =0
        on_start_line = False
        
    if start_line_time > 0.1 and not on_start_line:
        x = 0
        y = 0
        theta = 0
        on_start_line = True

  
    if state == "speed_measurement":
        left_w = MAX_SPEED
        right_w = MAX_SPEED
    
        left_motor.setVelocity(left_w)
        right_motor.setVelocity(right_w)
        if gs_values[0] < 700 and gs_values[2] < 700: # Left and Right Sensors
            state = "line_follower"

    elif state == "line_follower":
        forward = 0.8 * MAX_SPEED
        turn = 0.5 * MAX_SPEED
        
        # start line
        if gs_values[0] < 700 and gs_values[1] < 700 and gs_values[2] < 700:
            left_w = forward
            right_w = forward
        
        elif gs_values[1] < 700: # Center sensor  # Detects black line
        # while detect black line go forwards
            left_w = forward
            right_w = forward
                
        elif gs_values[0] < 700: 
            # if left sensor detects line, rotate to the left
            left_w = -turn
            right_w = turn 
                  
        elif gs_values[2] < 700:
            # if right sensor detects line, rotate to the left
            left_w = turn
            right_w = -turn 
        else:
            left_w = -turn
            right_w = turn # no sensors
            
    left_motor.setVelocity(left_w)
    right_motor.setVelocity(right_w)
    
    left_velocity = left_w * wheel_radius
    right_velocity = right_w * wheel_radius
    
    # Velocities
    
    velocity = (right_velocity + left_velocity) / 2
    angular_velocity = (right_velocity - left_velocity) / axle_length
    
    # Integration
    x += velocity * math.cos(theta) * dt
    y += velocity * math.sin(theta) * dt
    theta += angular_velocity * dt
    
    print(f"{x:.6f} {y:.6f} {theta:.6f}")
    
    

    
    # Odometry updates
    
    
         
    # Process sensor data here.

    # Enter here functions to send actuator commands, like:
    #  motor.setPosition(10.0)
    
    pass

# Enter here exit cleanup code.
